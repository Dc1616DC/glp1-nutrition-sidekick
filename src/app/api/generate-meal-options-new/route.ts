import { NextRequest, NextResponse } from 'next/server';
import { grokService } from '../../../services/grokService';
import { spoonacularNutritionService } from '../../../services/spoonacularNutritionService';
import { nutritionValidationService } from '../../../services/nutritionValidationNew';
import { curatedRecipeService } from '../../../services/curatedRecipes';
import { symptomMealService } from '../../../services/symptomMealService';
import { cacheService } from '../../../services/cacheService';
import { subscriptionService } from '../../../services/subscriptionService';
import { MealPreferences, Recipe } from '../../../types/recipe';
import { getAuth } from 'firebase-admin/auth';
import { initializeApp, getApps, cert } from 'firebase-admin/app';

// Increase timeout for comprehensive meal generation
export const maxDuration = 90;

export async function POST(request: NextRequest) {
  const startTime = Date.now();
  
  try {
    const requestBody = await request.json();
    console.log('üçΩÔ∏è New meal generation request:', requestBody);
    
    // Get user ID from authorization header for symptom integration
    let userId = null;
    let symptomEnhancement = '';
    
    try {
      const authHeader = request.headers.get('authorization');
      if (authHeader && authHeader.startsWith('Bearer ')) {
        // Initialize Firebase Admin if not already initialized
        if (getApps().length === 0) {
          const serviceAccount = JSON.parse(process.env.FIREBASE_ADMIN_SDK || '{}');
          initializeApp({
            credential: cert(serviceAccount)
          });
        }
        
        const token = authHeader.split('Bearer ')[1];
        const decodedToken = await getAuth().verifyIdToken(token);
        userId = decodedToken.uid;
        
        // Check if user has premium access for AI meal generation
        const hasPremiumAccess = await subscriptionService.hasPremiumAccess(userId);
        if (!hasPremiumAccess) {
          return NextResponse.json({
            error: 'Premium subscription required',
            message: 'AI meal generation is available for premium subscribers only.',
            upgradeUrl: '/analytics', // Where they can upgrade
            feature: 'ai_meal_generation'
          }, { status: 403 });
        }
        
        // Get symptom-based meal preferences
        console.log('üîç Analyzing symptoms for user:', userId);
        symptomEnhancement = await symptomMealService.createSymptomPromptEnhancement(userId);
        
        if (symptomEnhancement) {
          console.log('‚úÖ Added symptom-based optimizations to meal generation');
        }
      }
    } catch (authError) {
      console.log('‚ÑπÔ∏è No valid auth token:', authError);
      // AI meal generation requires premium subscription, which requires authentication
      return NextResponse.json({
        error: 'Authentication required',
        message: 'Please sign in to access AI meal generation. This feature requires a premium subscription.',
        upgradeUrl: '/analytics',
        feature: 'ai_meal_generation'
      }, { status: 401 });
    }
    
    // Parse enhanced preferences
    const preferences: any = {
      mealType: requestBody.mealType || 'lunch',
      dietaryRestrictions: requestBody.dietaryRestrictions || [],
      allergies: requestBody.allergies || [],
      numOptions: Math.min(requestBody.numOptions || 2, 3), // Limit to prevent timeout
      maxCookingTime: requestBody.maxCookingTime || 45,
      proteinTarget: requestBody.proteinTarget || 20,
      fiberTarget: requestBody.fiberTarget || 4,
      calorieRange: requestBody.calorieRange || { min: 400, max: 600 },
      creativityLevel: requestBody.creativityLevel || 'simple',
      assemblyToRecipeRatio: requestBody.assemblyToRecipeRatio || 60,
      availableIngredients: requestBody.availableIngredients || [], // Pantry ingredients
      symptomEnhancement // Add symptom enhancement to preferences
    };

    // Check if we should use fallback (for testing or API failures)
    if (requestBody.useFallback) {
      console.log('üìã Using curated recipes as requested');
      return await generateCuratedMeals(preferences);
    }

    // Check cache first
    const cachedResult = await cacheService.getCachedMealGeneration({
      preferences,
      mealType: preferences.mealType,
      userId
    });
    
    if (cachedResult) {
      console.log('üéØ Cache hit - returning cached meal generation');
      return NextResponse.json({
        ...cachedResult,
        cached: true,
        generationTime: 0
      });
    }

    let generatedRecipes: Recipe[] = [];

    try {
      // Step 1: Generate recipes with Grok AI
      console.log('ü§ñ Step 1: Generating recipes with Grok...');
      generatedRecipes = await grokService.generateGLP1Recipes(preferences);
      
      if (generatedRecipes.length === 0) {
        throw new Error('No recipes generated by Grok');
      }

      // Step 2: Calculate nutrition using USDA database first, Grok as fallback
      console.log('üìä Step 2: Calculating nutrition with USDA + Grok hybrid approach...');
      for (let i = 0; i < generatedRecipes.length; i++) {
        const recipe = generatedRecipes[i];
        
        // Use Grok's nutrition estimates as-is (they're more consistent than our buggy hybrid attempts)
        console.log(`ü§ñ Using Grok's nutrition estimates for "${recipe.title}": ${recipe.nutritionTotals?.protein || 0}g protein, ${recipe.nutritionTotals?.calories || 0} calories`);
        
        // Keep Grok's original estimates - they're already in recipe.nutritionTotals
        // No additional processing needed
      }

      // Step 3: Validate against GLP-1 requirements
      console.log('‚úÖ Step 3: Validating GLP-1 compliance...');
      const validatedRecipes: Recipe[] = [];
      
      for (let i = 0; i < generatedRecipes.length; i++) {
        const recipe = generatedRecipes[i];
        const validation = nutritionValidationService.validateGLP1Recipe(recipe);
        
        if (validation.valid || validation.score >= 70) {
          // Recipe is good enough
          validatedRecipes.push({
            ...recipe,
            glp1Notes: `${recipe.glp1Notes} | ${nutritionValidationService.generateNutritionDisclaimer(validation)}`
          });
          console.log(`‚úÖ Recipe "${recipe.title}" passed validation (score: ${validation.score})`);
        } else {
          // Try to fix the recipe
          console.log(`üîß Recipe "${recipe.title}" needs adjustment (score: ${validation.score})`);
          console.log('Issues:', validation.issues);
          
          try {
            const adjustedRecipe = await grokService.adjustRecipe(recipe, validation.issues);
            
            // Re-validate adjusted recipe
            const newValidation = nutritionValidationService.validateGLP1Recipe(adjustedRecipe);
            if (newValidation.valid || newValidation.score >= 60) {
              validatedRecipes.push(adjustedRecipe);
              console.log(`‚úÖ Adjusted recipe "${adjustedRecipe.title}" now passes (score: ${newValidation.score})`);
            } else {
              console.log(`‚ùå Could not fix recipe "${recipe.title}", skipping`);
            }
          } catch (adjustmentError) {
            console.error('Failed to adjust recipe:', adjustmentError);
            // Add original recipe with warnings
            validatedRecipes.push({
              ...recipe,
              glp1Notes: `‚ö†Ô∏è This recipe may not fully meet GLP-1 requirements: ${validation.issues.join(', ')}`
            });
          }
        }
      }

      if (validatedRecipes.length === 0) {
        throw new Error('No recipes passed validation');
      }

      const duration = Date.now() - startTime;
      console.log(`‚úÖ Successfully generated ${validatedRecipes.length} GLP-1 recipes in ${duration}ms`);
      
      const result = { 
        success: true,
        meals: validatedRecipes,
        source: 'grok-estimates',
        generationTime: duration,
        symptomOptimized: !!symptomEnhancement,
        disclaimer: '‚ö†Ô∏è Nutrition values are AI-generated estimates and may not be precise. Please verify against nutrition labels for exact values.'
      };
      
      // Cache successful results
      await cacheService.cacheMealGeneration(
        { preferences, mealType: preferences.mealType, userId },
        result
      );
      console.log('üíæ Cached meal generation results');
      
      return NextResponse.json(result);

    } catch (generationError) {
      console.error('‚ùå Recipe generation failed:', generationError);
      console.log('üîÑ Falling back to curated recipes...');
      return await generateCuratedMeals(preferences);
    }

  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`‚ùå Complete meal generation failure after ${duration}ms:`, error);
    
    return NextResponse.json(
      { 
        success: false,
        error: 'Failed to generate meal options',
        details: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString()
      },
      { status: 500 }
    );
  }
}

/**
 * Fallback to curated recipes when AI generation fails
 */
async function generateCuratedMeals(preferences: MealPreferences) {
  try {
    console.log('üìã Generating curated meal options...');
    
    const curatedMeals = curatedRecipeService.getRecipes({
      mealType: preferences.mealType,
      count: preferences.numOptions,
    });

    const meals = curatedMeals.map(meal => curatedRecipeService.convertToGeneratedMeal(meal));
    
    return NextResponse.json({
      success: true,
      meals,
      source: 'curated',
      symptomOptimized: !!symptomEnhancement,
      notice: 'Using curated recipes due to AI generation issues. These are manually verified GLP-1 friendly recipes.',
      fallback: true
    });
    
  } catch (fallbackError) {
    console.error('‚ùå Even fallback failed:', fallbackError);
    
    return NextResponse.json(
      { 
        success: false,
        error: 'All meal generation methods failed',
        details: 'Both AI generation and curated fallback failed',
        timestamp: new Date().toISOString()
      },
      { status: 500 }
    );
  }
}