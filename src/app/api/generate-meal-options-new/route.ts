import { NextRequest, NextResponse } from 'next/server';
import { grokService } from '../../../services/grokService';
import { spoonacularNutritionService } from '../../../services/spoonacularNutritionService';
import { nutritionValidationService } from '../../../services/nutritionValidationNew';
import { curatedRecipeService } from '../../../services/curatedRecipes';
import { MealPreferences, Recipe } from '../../../types/recipe';

// Increase timeout for comprehensive meal generation
export const maxDuration = 90;

export async function POST(request: NextRequest) {
  const startTime = Date.now();
  
  try {
    const requestBody = await request.json();
    console.log('üçΩÔ∏è New meal generation request:', requestBody);
    
    // Parse enhanced preferences
    const preferences: any = {
      mealType: requestBody.mealType || 'lunch',
      dietaryRestrictions: requestBody.dietaryRestrictions || [],
      allergies: requestBody.allergies || [],
      numOptions: Math.min(requestBody.numOptions || 2, 3), // Limit to prevent timeout
      maxCookingTime: requestBody.maxCookingTime || 45,
      proteinTarget: requestBody.proteinTarget || 20,
      fiberTarget: requestBody.fiberTarget || 4,
      calorieRange: requestBody.calorieRange || { min: 400, max: 600 },
      creativityLevel: requestBody.creativityLevel || 'simple',
      assemblyToRecipeRatio: requestBody.assemblyToRecipeRatio || 60
    };

    // Check if we should use fallback (for testing or API failures)
    if (requestBody.useFallback) {
      console.log('üìã Using curated recipes as requested');
      return await generateCuratedMeals(preferences);
    }

    // TODO: Add Firestore caching here
    // const cacheKey = hashPreferences(preferences);
    // Check cache first, return if hit

    let generatedRecipes: Recipe[] = [];

    try {
      // Step 1: Generate recipes with Grok AI
      console.log('ü§ñ Step 1: Generating recipes with Grok...');
      generatedRecipes = await grokService.generateGLP1Recipes(preferences);
      
      if (generatedRecipes.length === 0) {
        throw new Error('No recipes generated by Grok');
      }

      // Step 2: Use Grok's nutrition estimates (more reliable than Spoonacular API)
      console.log('üìä Step 2: Using Grok AI nutrition estimates...');
      for (let i = 0; i < generatedRecipes.length; i++) {
        const recipe = generatedRecipes[i];
        
        // Grok already provided nutrition estimates in the recipe
        if (recipe.nutritionTotals) {
          console.log(`‚úÖ Using Grok's nutrition estimates for "${recipe.title}": ${recipe.nutritionTotals.protein}g protein, ${recipe.nutritionTotals.calories} cal`);
        } else {
          console.log(`‚ö†Ô∏è No nutrition data from Grok for "${recipe.title}", will rely on validation step`);
        }
      }

      // Step 3: Validate against GLP-1 requirements
      console.log('‚úÖ Step 3: Validating GLP-1 compliance...');
      const validatedRecipes: Recipe[] = [];
      
      for (let i = 0; i < generatedRecipes.length; i++) {
        const recipe = generatedRecipes[i];
        const validation = nutritionValidationService.validateGLP1Recipe(recipe);
        
        if (validation.valid || validation.score >= 70) {
          // Recipe is good enough
          validatedRecipes.push({
            ...recipe,
            glp1Notes: `${recipe.glp1Notes} | ${nutritionValidationService.generateNutritionDisclaimer(validation)}`
          });
          console.log(`‚úÖ Recipe "${recipe.title}" passed validation (score: ${validation.score})`);
        } else {
          // Try to fix the recipe
          console.log(`üîß Recipe "${recipe.title}" needs adjustment (score: ${validation.score})`);
          console.log('Issues:', validation.issues);
          
          try {
            const adjustedRecipe = await grokService.adjustRecipe(recipe, validation.issues);
            
            // Re-validate adjusted recipe
            const newValidation = nutritionValidationService.validateGLP1Recipe(adjustedRecipe);
            if (newValidation.valid || newValidation.score >= 60) {
              validatedRecipes.push(adjustedRecipe);
              console.log(`‚úÖ Adjusted recipe "${adjustedRecipe.title}" now passes (score: ${newValidation.score})`);
            } else {
              console.log(`‚ùå Could not fix recipe "${recipe.title}", skipping`);
            }
          } catch (adjustmentError) {
            console.error('Failed to adjust recipe:', adjustmentError);
            // Add original recipe with warnings
            validatedRecipes.push({
              ...recipe,
              glp1Notes: `‚ö†Ô∏è This recipe may not fully meet GLP-1 requirements: ${validation.issues.join(', ')}`
            });
          }
        }
      }

      if (validatedRecipes.length === 0) {
        throw new Error('No recipes passed validation');
      }

      // TODO: Cache successful results in Firestore
      
      const duration = Date.now() - startTime;
      console.log(`‚úÖ Successfully generated ${validatedRecipes.length} GLP-1 recipes in ${duration}ms`);
      
      return NextResponse.json({ 
        success: true,
        meals: validatedRecipes,
        source: 'grok+nutrition',
        generationTime: duration,
        disclaimer: 'Recipes generated by Grok AI with built-in nutrition estimates, validated for GLP-1 compatibility.'
      });

    } catch (generationError) {
      console.error('‚ùå Recipe generation failed:', generationError);
      console.log('üîÑ Falling back to curated recipes...');
      return await generateCuratedMeals(preferences);
    }

  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`‚ùå Complete meal generation failure after ${duration}ms:`, error);
    
    return NextResponse.json(
      { 
        success: false,
        error: 'Failed to generate meal options',
        details: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString()
      },
      { status: 500 }
    );
  }
}

/**
 * Fallback to curated recipes when AI generation fails
 */
async function generateCuratedMeals(preferences: MealPreferences) {
  try {
    console.log('üìã Generating curated meal options...');
    
    const curatedMeals = curatedRecipeService.getRecipes({
      mealType: preferences.mealType,
      count: preferences.numOptions,
    });

    const meals = curatedMeals.map(meal => curatedRecipeService.convertToGeneratedMeal(meal));
    
    return NextResponse.json({
      success: true,
      meals,
      source: 'curated',
      notice: 'Using curated recipes due to AI generation issues. These are manually verified GLP-1 friendly recipes.',
      fallback: true
    });
    
  } catch (fallbackError) {
    console.error('‚ùå Even fallback failed:', fallbackError);
    
    return NextResponse.json(
      { 
        success: false,
        error: 'All meal generation methods failed',
        details: 'Both AI generation and curated fallback failed',
        timestamp: new Date().toISOString()
      },
      { status: 500 }
    );
  }
}